#include "otf2/otf2.h"
#include "otf2/OTF2_EvtWriter.h"
#include "otf2/OTF2_MPI_Collectives.h"
#include "record/wrap_defines.h"
#include "record/record_type_traits.h"
#include "record/record_reader.h"
#include "ral/section.hpp"
#include "ral/backend.h"
#include "fsl/fsl_section.hpp"
#include "utils/cxxopts.hpp"
#include <filesystem>
#include <magic_enum.hpp>
template <>
struct magic_enum::customize::enum_range<event> {
  static constexpr int min = 0;
  static constexpr int max = 500;
  // (max - min) must be less than UINT16_MAX.
};
#include <queue>
#include <set>
#include <unordered_map>

using std::unordered_map;
using pse::utils::GetField;
using namespace std::literals;

#define REC_MPI_COMM -1

bool force = false;
bool backtrace_enabled = false;
std::string input_dir;
std::string output_file_path;
std::string event_file_path;
std::string dump_dir;
uint64_t time_offset;
uint64_t interval_length;
uint64_t number_of_events;
int size = -1;
unsigned int ranks = -1;
namespace fs = std::filesystem;

enum
{
    REGION_0,
    REGION_1,
    REGION_2,
    REGION_3,
    REGION_4,
    REGION_5,
    REGION_6,
    REGION_7,
    REGION_8,
    REGION_9,
    REGION_10,
    REGION_11,
};

static OTF2_FlushType
pre_flush(void *userData, OTF2_FileType fileType, OTF2_LocationRef location, void *callerData, bool final)
{
    return OTF2_FLUSH;
}

static OTF2_FlushCallbacks flush_callbacks = {.otf2_pre_flush = pre_flush, .otf2_post_flush = nullptr};
void parse(int argc, char *argv[])
{
    cxxopts::Options options("jsiextract", "extract trace data from jsi formt and convert to otf2");
    options.add_options()("b,backtrace", "Read backtrace information")(
        "e,event_file", "events that need to extract", cxxopts::value<std::string>())
("h,help", "Print help")(
        "l,line_info_dump", "Input line info directory dumped by dwarf_line_info_dump", cxxopts::value<std::string>())(
        "i,input", "Input measurement directory generated by jsirun", cxxopts::value<std::string>())(
        "o,output",
        "Output directory to store the readable outputs",
        cxxopts::value<std::string>()->default_value("readable"))
        ("t,time_offset", "Time offset of starting timestamps(ms). Default is 0", cxxopts::value<int64_t>()->default_value("0"))(
            "interval_length", "Time interval length of the trace (ms). Default is -1(inf).", cxxopts::value<int64_t>()->default_value("-1")
        )
        (
        "n,number_of_events", "Number of events per rank. Default is -1(inf)", cxxopts::value<int>()->default_value("-1"))
        ("r,ranks"," Number of ranks to extract. Default is -1(inf)", cxxopts::value<int>()->default_value("-1"));

    try
    {
        auto result = options.parse(argc, argv);
        // print help message if configured
        if (result.count("help"))
        {
            std::cout << options.help() << std::endl;
            exit(1);
        }
        if (result.count("input") >= 1)
        {
            if (result.count("input") > 2)
            {
                std::cout << "Warning: multiple input directory configured. Only use the last one!" << std::endl;
            }
            input_dir = result["input"].as<std::string>();
        }
        else
        {
            std::cout << "-i or --input must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("output"))
        {
            output_file_path = result["output"].as<std::string>();
        }
        if (result.count("force"))
        {
            force = true;
        }
        if (result.count("backtrace"))
        {
            backtrace_enabled = true;
        }
        if (result.count("event_file"))
        {
            event_file_path = result["event_file"].as<std::string>();
        }
        if (result.count("ranks"))
        {
            ranks = result["ranks"].as<int>();
        }

        if (result.count("line_info_dump") >= 1) {
            if (result.count("line_info_dump") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            dump_dir = result["line_info_dump"].as<std::string>();
        } else {
            std::cout << "-l or --line_info_dump not specified! Runtime dwarf addr2line will be used, which will cause a great slowdown!" << std::endl;
        }
        number_of_events = result["number_of_events"].as<int>();
        time_offset = result["time_offset"].as<int64_t>();
        interval_length = result["interval_length"].as<int64_t>();
        std::cout << "Configured: " << std::endl;
        std::cout << "\t"
                  << "Input: " << input_dir << std::endl;
    } catch (cxxopts::exceptions::exception e)
    {
        std::cout << "Error: " << e.what() << std::endl;
        std::cout << options.help() << std::endl;
        exit(1);
    }
}

void write_MpiSend(OTF2_EvtWriter *writer, const record_comm_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiSend(writer,
                           attr,
                           record->record.timestamps.enter,
                           record->dest,
                           REC_MPI_COMM,
                           record->tag,
                           record->count * record->typesize);
}

void write_MpiRecv(OTF2_EvtWriter *writer, const record_comm_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiRecv(writer,
                           attr,
                           record->record.timestamps.enter,
                           // FIXME: sender?
                           record->dest,
                           REC_MPI_COMM,
                           record->tag,
                           record->count * record->typesize);
}

void write_MpiIsend(OTF2_EvtWriter *writer, const record_comm_async_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiIsend(writer,
                            attr,
                            record->record.timestamps.enter,
                            record->dest,
                            REC_MPI_COMM,
                            record->tag,
                            record->count * record->typesize,
                            record->request);
}

void write_MpiIsendComplete(OTF2_EvtWriter *writer, const record_comm_async_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiIsendComplete(writer, attr, record->record.timestamps.exit, record->request);
}

void write_MpiIRecvRequest(OTF2_EvtWriter *writer, const record_comm_async_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiIrecvRequest(writer, attr, record->record.timestamps.enter, record->request);
}
void write_MpiIRecv(OTF2_EvtWriter *writer, const record_comm_async_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiIrecv(writer,
                            attr,
                            record->record.timestamps.exit,
                            // FIXME: sender?
                            record->dest,
                            REC_MPI_COMM,
                            record->tag,
                            record->count * record->typesize,
                            record->request);
}

void write_MpiBcast_end(OTF2_EvtWriter *writer, const record_bcast_t *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiCollectiveEnd(writer,
                                    attr,
                                    record->record.timestamps.exit,
                                    OTF2_COLLECTIVE_OP_BCAST,
                                    REC_MPI_COMM,
                                    record->root,
                                    record->count * record->typesize,
                                    0);
}


template <typename T>
void write_MpiCollectiveBegin(OTF2_EvtWriter *writer, const T *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiCollectiveBegin(writer, attr, record->timestamps.enter);
}

template <typename T, auto op>
void write_MpiCollectiveEnd(OTF2_EvtWriter *writer, const T *record, OTF2_AttributeList *attr)
{
    OTF2_EvtWriter_MpiCollectiveEnd(
        writer,
        attr,
        record->record.timestamps.exit,
        op,
        REC_MPI_COMM,
        PSE_GETFIELD_V_OR(*record, "root"sv, -1),
        GetField<T, []() { return "sendcnt"sv; }, []() { return "count"sv; }>::get_field_v_or(*record, 0) *
            PSE_GETFIELD_V_OR(*record, "typesize"sv, 0),
        GetField<T, []() { return "recvcnt"sv; }, []() { return "count"sv; }>::get_field_v_or(*record, 0) *
            PSE_GETFIELD_V_OR(*record, "typesize"sv, 0));
}

void write_MpiBarrier_end(OTF2_EvtWriter *writer, const record_barrier_t *record)
{
    OTF2_EvtWriter_MpiCollectiveEnd(
        writer, nullptr, record->record.timestamps.exit, OTF2_COLLECTIVE_OP_BARRIER, REC_MPI_COMM, -1, 0, 0);
}

std::set<event> events;
void load_events()
{
    FILE *f = fopen(event_file_path.c_str(), "r");
    if (!f)
    {
        JSI_ERROR("event file: %s not exists\n", event_file_path.c_str());
        exit(-1);
    }
    char buffer[256];
    while (true)
    {
        fgets(buffer, 256, f);
        if (feof(f))
        {
            break;
        }
        auto sv = std::string_view(buffer);
        sv.remove_suffix(1);
        auto e = magic_enum::enum_cast<event>(sv);
        spdlog::info("event enum has value {} with str {}", e.has_value(), buffer);
        events.insert(e.value());
    }
}
void write_otf2(const std::string &output_file_dir,
                const std::string &output_file_name,
                RecordTraceCollection &traces,
                BacktraceCollection &backtraces)
{
    OTF2_Archive *archive = OTF2_Archive_Open(output_file_dir.data(),
                                              output_file_name.data(),
                                              OTF2_FILEMODE_WRITE,
                                              1024 * 1024,
                                              4 * 1024 * 1024,
                                              OTF2_SUBSTRATE_POSIX,
                                              OTF2_COMPRESSION_NONE);
    OTF2_Archive_SetFlushCallbacks(archive, &flush_callbacks, NULL);
    // OTF2_MPI_Archive_SetCollectiveCallbacks( archive,
    //                                          0,
    //                                          0 );
    OTF2_Archive_SetSerialCollectiveCallbacks(archive);
    OTF2_Archive_OpenEvtFiles(archive);
    struct CMP
    {
        bool operator()(const record_t *a, const record_t *b) const { return a->timestamps.exit > b->timestamps.exit; }
    };
    std::priority_queue<record_t *, std::vector<record_t *>, CMP> pq;
    std::vector<int> ids;

    std::unordered_map<std::string, int> backtrace2id;
    int i = 0;
    OTF2_GlobalDefWriter *global_def_writer = OTF2_Archive_GetGlobalDefWriter(archive);
    uint64_t global_epoch_start = -1, global_epoch_end = 0;
    std::unordered_map<int, int> event_num_map;
    std::vector<int> appeared_msgType;
    std::vector<std::string> appeared_record_name;

    for (auto &[id, trace] : traces)
    {
        ids.push_back(id);
        event_num_map[i] = 0;
        OTF2_EvtWriter *writer = OTF2_Archive_GetEvtWriter(archive, i++);
        uint64_t start_timestamp = 0;
        uint64_t events_recorded = 0;
        for (auto it = trace->begin(); it != trace->end(); it = it.next())
        {
            auto record = it.val();
            auto msgType = record->MsgType;
            
            appeared_msgType.push_back(msgType);
            appeared_record_name.push_back(RecordHelper::get_record_name(record));
            // appeared_record.push_back(record);

            if (start_timestamp == 0)
            {
                start_timestamp = record->timestamps.enter;
            }
            if (record->timestamps.enter - start_timestamp < time_offset * 1e6)
            {
                continue;
            }
            if (record->timestamps.enter - start_timestamp > interval_length * 1e6)
            {
                break;
            }
            if (events.find((event)msgType) == events.end())
            {
                continue;
            }

            events_recorded++;
            if (events_recorded > number_of_events)
            {
                break;
            }

            auto backtrace = backtraces.at(id)->backtrace_get_context_string(record->ctxt);
            auto [iter, inserted] = backtrace2id.try_emplace(backtrace, backtrace2id.size());
            if (inserted)
            {
                // spdlog::info("backtrace: {}", backtrace);
                OTF2_GlobalDefWriter_WriteString(global_def_writer, iter->second, backtrace);
            }

            auto current_time = record->timestamps.enter;
            if (current_time < global_epoch_start)
                global_epoch_start = current_time;
            if (record->timestamps.exit > global_epoch_end)
                global_epoch_end = record->timestamps.exit;

            while (!pq.empty() && pq.top()->timestamps.exit <= current_time)
            {
                auto record = pq.top();
                pq.pop();
                auto msgType = record->MsgType;
                // appeared_record.push_back(record);
                appeared_msgType.push_back(msgType);
                appeared_record_name.push_back(RecordHelper::get_record_name(record));
                auto backtrace_id = backtrace2id.at(backtraces.at(id)->backtrace_get_context_string(record->ctxt));

                OTF2_AttributeList *attr = OTF2_AttributeList_New();
                OTF2_AttributeValue attr_value;
                attr_value.uint32 = backtrace_id;

                OTF2_AttributeList_AddAttribute(attr, 0, OTF2_TYPE_UINT32, attr_value);
                attr=NULL;
                event_num_map[i-1]++;
                switch ((event)msgType)
                {
                case event::MPI_Isend:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiIsendComplete(writer, (record_comm_async_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                case event::MPI_Irecv:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiIRecv(writer, (record_comm_async_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                case event::MPI_Alltoall:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiCollectiveEnd<record_all2all_t, OTF2_COLLECTIVE_OP_ALLREDUCE>(
                        writer, (record_all2all_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                case event::MPI_Allreduce:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiCollectiveEnd<record_allreduce_t, OTF2_COLLECTIVE_OP_ALLREDUCE>(
                        writer, (record_allreduce_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                case event::MPI_Reduce:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiCollectiveEnd<record_reduce_t, OTF2_COLLECTIVE_OP_REDUCE>(
                        writer, (record_reduce_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                case event::MPI_Bcast:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiCollectiveEnd<record_bcast_t, OTF2_COLLECTIVE_OP_BCAST>(
                        writer, (record_bcast_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                case event::MPI_Barrier:
                    OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                    write_MpiCollectiveEnd<record_barrier_t, OTF2_COLLECTIVE_OP_BARRIER>(
                        writer, (record_barrier_t *)record, attr);
                    OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                    break;
                // default:
                //     OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                //     OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                }
                // spdlog::info("current_time exit: {}", record->timestamps.exit);
            }
            // spdlog::info("current_time: {}", current_time);

            auto backtrace_id = backtrace2id.at(backtraces.at(id)->backtrace_get_context_string(record->ctxt));
            OTF2_AttributeList *attr = OTF2_AttributeList_New();
            OTF2_AttributeValue attr_value;
            attr_value.uint32 = backtrace_id;

            OTF2_AttributeList_AddAttribute(attr, 0, OTF2_TYPE_UINT32, attr_value);
            attr=NULL;
            event_num_map[i-1]++;
            switch ((event)msgType)
            {
            case event::MPI_Send:
                OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                write_MpiSend(writer, (record_comm_t *)record, attr);
                OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                break;
            case event::MPI_Recv:
                OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                write_MpiRecv(writer, (record_comm_t *)record, attr);
                OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                break;
            case event::MPI_Isend:
                OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                write_MpiIsend(writer, (record_comm_async_t *)record, attr);
                pq.push(record);
                OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                break;
            case event::MPI_Irecv:
                OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                write_MpiIRecvRequest(writer, (record_comm_async_t *)record, attr);
                pq.push(record);
                OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
                break;
            case event::MPI_Alltoall:
            case event::MPI_Allreduce:
            case event::MPI_Reduce:
            case event::MPI_Bcast:
            case event::MPI_Barrier:
                OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
                write_MpiCollectiveBegin(writer, record, attr);
                OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.enter, msgType);
                pq.push(record);
                break;
            // default:
            //     OTF2_EvtWriter_Enter(writer, NULL, record->timestamps.enter, msgType);
            //     OTF2_EvtWriter_Leave(writer, NULL, record->timestamps.exit, msgType);
            }
        }
        OTF2_Archive_CloseEvtWriter(archive, writer);

         //! [deffiles]
        OTF2_Archive_OpenDefFiles( archive );
        OTF2_DefWriter* def_writer = OTF2_Archive_GetDefWriter( archive, i - 1);
        OTF2_Archive_CloseDefWriter( archive, def_writer );
        OTF2_Archive_CloseDefFiles( archive );
        //! [deffiles]

        delete trace;
        trace = nullptr;
        if (i >= ranks)
        {
            break;
        }
        
    }
    OTF2_Archive_CloseEvtFiles(archive);
    // OTF2_GlobalDefWriter *global_def_writer = OTF2_Archive_GetGlobalDefWriter(archive);

    OTF2_GlobalDefWriter_WriteClockProperties(global_def_writer, 1000000000, 
            global_epoch_start, global_epoch_end - global_epoch_start + 1, OTF2_UNDEFINED_TIMESTAMP);
    
    OTF2_GlobalDefWriter_WriteSystemTreeNode( global_def_writer,
                                                  0 /* id */,
                                                  20 /* name */,
                                                  21 /* class */,
                                                  OTF2_UNDEFINED_SYSTEM_TREE_NODE /* parent */ );

    size = i;
    for (int r = 0; r < size; r++)
    {
        char process_name[32];
        snprintf(process_name, sizeof(process_name), "MPI Rank %d", ids[r]);
        OTF2_GlobalDefWriter_WriteString(global_def_writer, backtrace2id.size() + r, process_name);

        OTF2_GlobalDefWriter_WriteLocationGroup(global_def_writer,
                                                r /* id */,
                                                r + backtrace2id.size() /* name */,
                                                OTF2_LOCATION_GROUP_TYPE_PROCESS,
                                                0 /* system tree */,
                                                OTF2_UNDEFINED_LOCATION_GROUP /* creating process */);

        OTF2_GlobalDefWriter_WriteLocation(global_def_writer,
                                           r /* id */,
                                           r + backtrace2id.size() /* name */,
                                           OTF2_LOCATION_TYPE_CPU_THREAD,
                                           event_num_map[r] /* # events */,
                                           r /* location group */);
    }

    // Write Region Name
    // std::cout << "\n\n write region name\n\n" << std::endl;
    for (int r = 0; r < appeared_msgType.size(); r++){
        // if (r < 5) {
        //     std::cout << r << " \n" << std::endl;
        //     std::cout << backtrace2id.size() + size + r << std::endl;
        //     std::cout << appeared_msgType[r] << std::endl;
        //     std::cout << appeared_record_name[r] << std::endl;
        // }
        OTF2_GlobalDefWriter_WriteString(global_def_writer, backtrace2id.size() + size + r, appeared_record_name[r].c_str());
        OTF2_GlobalDefWriter_WriteRegion( global_def_writer,
                                          appeared_msgType[r],
                                          backtrace2id.size() + size + r /* region name  */,
                                          backtrace2id.size() + size + r /* alternative name */,
                                          0 /* description */,
                                          OTF2_REGION_ROLE_FUNCTION,
                                          OTF2_PARADIGM_MPI,
                                          OTF2_REGION_FLAG_NONE,
                                          22 /* source file */,
                                          0 /* begin lno */,
                                          0 /* end lno */ );
    }

    OTF2_Archive_CloseGlobalDefWriter(archive, global_def_writer);

    OTF2_Archive_Close(archive);
}

int main(int argc, char *argv[])
{
    parse(argc, argv);
    // spdlog::info("hello");
    try
    {
        RecordReader reader(input_dir.c_str(), DATA_MODEL, dump_dir.empty() ? nullptr : dump_dir.c_str());
        RecordTraceCollection &traces = reader.get_all_traces();
        BacktraceCollection &backtraces = reader.get_all_backtraces();
        load_events();
        write_otf2(output_file_path, "trace", traces, backtraces);

    } catch (fs::filesystem_error const &e)
    {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    return 0;
}