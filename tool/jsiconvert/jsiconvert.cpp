#include <variant>
#include "fsl/raw_backend.h"
#include "ral/backend.h"
#include "record/record_type.h"
#include "record/wrap_defines.h"
#include "utils/cxxopts.hpp"
#include <filesystem>
#include <unordered_map>
using std::unordered_map;
#include "record/record_type_traits.h"
#include "record/record_type_info.h"
#include "instrument/backtrace.h"

bool force = false;
bool backtrace_enabled = false;
std::string input_dir;
std::string output_file_path;
int size = -1;
namespace fs = std::filesystem;
void parse(int argc, char *argv[])
{
    cxxopts::Options options("jsiread", "Read the measurement directory generated by jsirun.");
    options.add_options()("b,backtrace", "Read backtrace information")("d,dump", "Dump readable outputs")(
        "f,force", "Force to remove the output directory if already exists.")("h,help", "Print help")(
        "l,line_info_dump", "Input line info directory dumped by dwarf_line_info_dump", cxxopts::value<std::string>())(
        "i,input", "Input measurement directory generated by jsirun", cxxopts::value<std::string>())(
        "o,output",
        "Output directory to store the readable outputs",
        cxxopts::value<std::string>()->default_value("readable"));

    try
    {
        auto result = options.parse(argc, argv);
        // print help message if configured
        if (result.count("help"))
        {
            std::cout << options.help() << std::endl;
            exit(1);
        }
        if (result.count("input") >= 1)
        {
            if (result.count("input") > 2)
            {
                std::cout << "Warning: multiple input directory configured. Only use the last one!" << std::endl;
            }
            input_dir = result["input"].as<std::string>();
        }
        else
        {
            std::cout << "-i or --input must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("output"))
        {
            output_file_path = result["output"].as<std::string>();
        }
        if (result.count("force"))
        {
            force = true;
        }
        if (result.count("backtrace"))
        {
            backtrace_enabled = true;
        }
        std::cout << "Configured: " << std::endl;
        std::cout << "\t" << "Input: " << input_dir << std::endl;
    } catch (cxxopts::exceptions::exception e)
    {
        std::cout << "Error: " << e.what() << std::endl;
        std::cout << options.help() << std::endl;
        exit(1);
    }
}
int main(int argc, char *argv[])
{
    parse(argc, argv);
    spdlog::info("hello");
    try
    {
        RecordReader reader(input_dir.c_str(), DATA_MODEL, nullptr);
        RecordTraceCollection &traces = reader.get_all_traces();
        BacktraceCollection &backtraces = reader.get_all_backtraces();
        RankMetaCollection &metas = reader.get_all_meta_maps();
        // auto backend = pse::ral::Backend::open("output.db", pse::ral::Backend::BackendMode::SECTION_FILE, pse::ral::RWMode::WRITE);
        // auto root = backend->openRootSection();
        // unordered_map<int, pse::ral::DirSection> dirs;
        if (!force)
        {
            if (fs::exists(output_file_path))
            {
                std::cout << "Output directory already exists. Please use -f to force remove it." << std::endl;
                exit(1);
            }
        }
        if (fs::exists(output_file_path + ".lock"))
        {
            fs::remove(output_file_path + ".lock");
        }
        if (fs::exists(output_file_path))
        {
            fs::remove(output_file_path);
        }
        auto raw_backend = pse::fsl::RawSectionBackend(output_file_path, pse::ral::RWMode::WRITE);
        auto backend = pse::ral::BackendWrapper(std::move(raw_backend));

        auto root = backend.openRootSection();
        auto meta_ext = fs::path(JSI_META_FILE_EXT);

        auto trace_dir = root->openDirSection(StaticSectionDesc::TRACE_SEC_ID, true);
        auto backtrace_dir = root->openDirSection(StaticSectionDesc::BACKTRACE_SEC_ID, true);
        spdlog::info("open root section");

        for (const auto &dirEntry: fs::directory_iterator(input_dir)) {
            if (dirEntry.is_regular_file()) {
                const auto &path = dirEntry.path();
                if (path.extension() == meta_ext) {
                    FILE* f = fopen(path.c_str(), "rb");
                    fseek(f, 0, SEEK_END);
                    auto size = ftell(f);
                    fseek(f, 0, SEEK_SET);
                    auto buffer = new char[size];
                    fread(buffer, 1, size, f);
                    fclose(f);
                    auto meta = RecordMeta(path.c_str());
                    MetaDataMap::MetaValue_t *value_ranks;
                    meta.getMetaMap().at("MPI_COMM_WORLD")->get("rank", &value_ranks);
                    auto id = value_ranks->i32 + 1;
                    auto dir0 = trace_dir->openDirSection(id, true);
                    auto dir = dir0->openDirSection(id, true);
                    dir0->openStreamSection(StaticSectionDesc::META_SEC_OFFSET, true)->write(buffer, size);
                }
            }
        }

        spdlog::info("write meta section finish");
        for (const auto &[id, trace] : traces)
        {
            auto num_events = trace->num_pmu_events();
            auto dir0 = trace_dir->openDirSection(id+1, true);
            auto dir = dir0->openDirSection(id+1, true);
            auto generic_dir = dir->openDirSection(StaticSectionDesc::GENERIC_TRACE_SEC_ID, true);

            for (auto it = trace->begin(); it != trace->end(); it = it.next())
            {
                char* ptr = nullptr;
                bool is_allocated = false;
                auto msgType = it.val()->MsgType;
                if (msgType == -2)
                {
                    msgType = JSI_PROCESS_START;
                    ptr = new char[record_info[msgType].size + num_events * sizeof(uint64_t) * 2];
                    memcpy(ptr, it.val(), record_info[msgType].size + num_events * sizeof(uint64_t) * 2);
                    ((record_t*)ptr)->MsgType = JSI_PROCESS_START;
                    is_allocated = true;
                }
                else if (msgType == -3)
                {
                    // continue;
                    msgType = JSI_PROCESS_EXIT;
                    ptr = new char[record_info[msgType].size + num_events * sizeof(uint64_t) * 2];
                    memcpy(ptr, it.val(), record_info[msgType].size + num_events * sizeof(uint64_t) * 2);
                    ((record_t*)ptr)->MsgType = JSI_PROCESS_EXIT;
                    is_allocated = true;
                }
                else
                {
                    ptr = (char*)it.val();
                }
                if (msgType < 0 || msgType >= sizeof(record_info)/sizeof(record_info[0]))
                    continue;
                auto type_desc = 
                    pse::utils::EncodedStruct{
      record_info[msgType].field_ptrs,
     record_info[msgType].field_types,
     record_info[msgType].field_offsets,
     record_info[msgType].field_names,
     record_info[msgType].variable_field_offset,
     record_info[msgType].size + num_events * sizeof(uint64_t) * 2,
                        };
                auto dataSec = generic_dir->openDataSection(
                    msgType + StaticSectionDesc::RECORD_SEC_OFFSET, true,  type_desc, record_time_offset[msgType]);
                dataSec->write((record_t*)ptr);
                if (is_allocated)
                {
                    delete[] ptr;
                }
            }
        }

        for (auto &[id, backtrace]: backtraces)
        {
            auto dir = backtrace_dir->openDirSection(id+1, true);
            // auto dir = dir0->openDirSection(id+1, true);
            backtrace->backtrace_db_dump(dir);
        }

    } catch (fs::filesystem_error const &e)
    {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    return 0;
}