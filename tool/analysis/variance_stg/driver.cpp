#include "variance.h"
#include <iostream>
#include "utils/cxxopts.hpp"
#include "record/record_reader.h"
#include <filesystem>
#include <stdio.h>
#include "../timeline/alignment.h"
#include "../graph/dependancy_graph.h"

namespace fs = std::filesystem;

bool is_force = false;
std::string input_dir;
std::string output_dir;
std::string ref_metric;

void parse(int argc, char *argv[]) {
    cxxopts::Options options("variance_analysis", "Read the measurement directory generated by jsirun and generate variance analysis results.");
    options.add_options()
        ("f,force", "Force to overwrite the output file if already exists.")
        ("h,help", "Print help")
        ("i,input", "Input measurement directory generated by jsirun", cxxopts::value<std::string>())
        ("o,output", "Output directory to store the variance csv outputs.",cxxopts::value<std::string>()->default_value("variance"))
        ("m,reference-metric", "Reference metric for variance analysis (default: PAPI_TOT_INS)",cxxopts::value<std::string>()->default_value("PAPI_TOT_INS"))
        ;

    try {
        auto result = options.parse(argc, argv);
        // print help message if configured
        if (result.count("help")) {
            std::cout << options.help() << std::endl;
            exit(1);
        }
        if (result.count("input")>=1) {
            if(result.count("input")>2) {
                std::cout << "Warning: multiple input directory configured. Only use the last one!" << std::endl;
            }
            input_dir = result["input"].as<std::string>();
        } else {
            std::cout << "-i or --input must be specified!" << std::endl;
            exit(1);
        }
        output_dir = result["output"].as<std::string>();
        if (result.count("force")) {
            is_force = true;
        }
        ref_metric = result["reference-metric"].as<std::string>();
        std::cout << "Configured: " << std::endl;
        std::cout << "\t" << "Input: " << input_dir << std::endl;
        std::cout << "\t" << "Output: " << output_dir << std::endl;
        std::cout << "\t" << "Reference metric: " << ref_metric << std::endl;
    } catch (cxxopts::exceptions::exception &e) {
        std::cout << "Error: " << e.what() << std::endl;
        std::cout << options.help() << std::endl;
        exit(1);
    }
}

int main(int argc, char *argv[]) {
    // arg parse
    parse(argc, argv);
    try {
        if(fs::exists(output_dir)) {
            if(is_force) {
                fs::remove_all(output_dir);
            } else {
                std::cout << "Error: output directory (" << output_dir << ") exists!" << std::endl;
                exit(1);
            }
        }
        if(!fs::create_directories(output_dir)) {
            std::cout << "Error: failed to create output directory (" << output_dir << ")!" << std::endl;
            exit(1);
        }
        fs::path comm_out(output_dir);
        comm_out /= "comm.csv";
        fs::path calc_out(output_dir);
        calc_out /= "calc.csv";
        fs::path host_map(output_dir);
        host_map /= "host.csv";
        RecordReader reader(input_dir.c_str(),DATA_MODEL);
        RecordTraceCollection& traces = reader.get_all_traces();
        RankMetaCollection& metas = reader.get_all_meta_maps();
        BacktraceCollection& backtraces = reader.get_all_backtraces();
        // Align traces for each host nodes first
        BF_TimelineAlignment ta;
        ta.align(traces, metas);
        VarianceMap vmap(traces, backtraces, ref_metric);
        vmap.dump_comm_csv(comm_out.c_str());
        vmap.dump_calc_csv(calc_out.c_str());
        // dumping host name info
        FILE* fp = fopen(host_map.c_str(), "w");
        for (auto it = traces.begin(), ie = traces.end(); it != ie; ++it) {
            int rank = it->first;
            MetaDataMap::MetaValue_t *t;
            const std::unordered_map<std::string, MetaDataMap *> & metaMap = metas[rank]->getMetaMap();
            metaMap.at("HOST INFO")->get("HOSTNAME", &t);
            fprintf(fp, "%d,%s\n", rank, t->ptr);
        }
        fclose(fp);
    } catch (fs::filesystem_error const& e) {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    return 0;
}