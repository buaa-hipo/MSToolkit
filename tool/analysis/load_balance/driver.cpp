#include <filesystem>
#include <iostream>

#include "../graph/dependancy_graph.h"
#include "../timeline/alignment.h"
#include "load_balance.h"
#include "utils/cxxopts.hpp"

namespace fs = std::filesystem;

bool is_force = false;
std::string input_dir;
std::string output;
std::string dump_dir;
double threshold;
int num_top_k;

void parse(int argc, char* argv[]) {
    cxxopts::Options options("load_balance_analysis",
                             "Read the measurement directory generated by jsirun and generate load "
                             "balance analysis results. Backtraces are needed for this analysis.");
    options.add_options()
            ("t,threshold", "Load balance threshold.", cxxopts::value<double>()->default_value("1.0"))
            ("k,top-k", "Load balance Top-K count.", cxxopts::value<int>()->default_value("5"))

            ("f,force", "Force to overwrite the output file if already exists.")
            ("h,help", "Print help")
            ("i,input", "Input measurement directory generated by jsirun",
                         cxxopts::value<std::string>())
	    ("d,line_info_dump", "Input line info directory dumped by dwarf_line_info_dump",
                         cxxopts::value<std::string>())
            ("o,output", "Output file to store the chrome trace json outputs",
                         cxxopts::value<std::string>()->default_value("load_balance.report.txt"))
            ;

    try {
        auto result = options.parse(argc, argv);
        // print help message if configured
        if (result.count("help")) {
            std::cout << options.help() << std::endl;
            exit(1);
        }
        if (result.count("input") >= 1) {
            if (result.count("input") > 2) {
                std::cout << "Warning: multiple input directory configured. Only use the last one!"
                          << std::endl;
            }
            input_dir = result["input"].as<std::string>();
        } else {
            std::cout << "-i or --input must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("line_info_dump") >= 1) {
            if (result.count("line_info_dump") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            dump_dir = result["line_info_dump"].as<std::string>();
        } else {
            std::cout << "-d or --line_info_dump must be specified!" << std::endl;
            exit(1);
        }
        output = result["output"].as<std::string>();
        num_top_k = result["top-k"].as<int>();
        threshold = result["threshold"].as<double>();
//        threshold = std::stod(result["threshold"].as<std::string>());

        if (result.count("force")) {
            is_force = true;
        }
        std::cout << "Configured: " << std::endl;
        std::cout << "\t"
                  << "Input: " << input_dir << std::endl;
        std::cout << "\t"
                  << "Output: " << output << std::endl;
        std::cout << "\t"
                  << "Threshold: " << threshold << ", "
                  << "Number of top-k ranks: " << num_top_k
                  << std::endl;
    } catch (const cxxopts::exceptions::exception& e) {
        std::cout << "Error: " << e.what() << std::endl;
        std::cout << options.help() << std::endl;
        exit(1);
    }
}

int main(int argc, char* argv[]) {
    // arg parse
    parse(argc, argv);
    try {
        if (fs::exists(output)) {
            if (is_force) {
                fs::remove(output);
            } else {
                std::cout << "Error: output file (" << output << ") exists!" << std::endl;
                exit(1);
            }
        }
        RecordReader reader(input_dir.c_str(),DATA_MODEL,dump_dir.c_str());
        RecordTraceCollection& traces = reader.get_all_traces();
        RankMetaCollection& metas = reader.get_all_meta_maps();
        BacktraceCollection& backtraces = reader.get_all_backtraces();
        // Align traces for each host nodes first
        TimelineAlignment ta;
        ta.align(traces, metas);
        std::cout << "[main] Constructing dependancy graph..." << std::endl;

        auto t1 = std::chrono::steady_clock::now();
        DependancyGraph* graph = CreateDependancyGraph(traces, metas, false);
        auto t2 = std::chrono::steady_clock::now();
        printf("Time creating dependancy graph: %f\n", std::chrono::duration<double>(t2 - t1).count());
        std::cout << "[main] Constructing load balance analyzer..." << std::endl;
        auto analyzer = LoadBalanceAnalyzer(graph, &backtraces, threshold, num_top_k);
        std::cout << "[main] Analyzing..." << std::endl;
        auto t3 = std::chrono::steady_clock::now();
        analyzer.analyze();
        auto t4 = std::chrono::steady_clock::now();
        printf("Time analyzing: %f\n", std::chrono::duration<double>(t4 - t3).count());
        analyzer.dump_report(output.c_str());
        delete graph;
    } catch (fs::filesystem_error const& e) {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    return 0;
}
