#include "dependancy_graph.h"
#include <iostream>
#include "utils/cxxopts.hpp"
#include "record/record_reader.h"
#include <filesystem>
#include <stdio.h>
#include "../timeline/alignment.h"

namespace fs = std::filesystem;

bool dry_run = false;
bool edges_only = false;
bool bt_only = false;
bool is_force = false;
std::string input_dir;
std::string output;
std::string dump_dir;
std::string fb_dir;
uint64_t interval;
uint64_t duration;
int mode;


void parse(int argc, char *argv[]) {
    cxxopts::Options options("timeslice_analysis_all", "Read the measurement directory generated by jsirun and generate CSV files that consolidate cpu and gpu event information based on given time slice sizes.");
    options.add_options()
        ("f,force", "Force to overwrite the output file if already exists.")
        ("h,help", "Print help")
        ("d,line_info_dump", "Input line info directory dumped by dwarf_line_info_dump", cxxopts::value<std::string>())
        ("n,dry_run", "Dry run (no file output)")
        ("e,edges_only", "Print edge info only")
        ("b,bt_only", "Print backtrace info only")
        ("s,filter_bt", "Input backtrace filter directory", cxxopts::value<std::string>())
        ("i,input", "Input measurement directory generated by jsirun", cxxopts::value<std::string>())
        ("o,output", "Output file to store the csv outputs",cxxopts::value<std::string>()->default_value("graph"))
        ("l,interval", "Time interval between two time slice(ms)", cxxopts::value<uint64_t>())
        ("u,duration", "Time duration of one time slice(ms)", cxxopts::value<uint64_t>())
        ("m,mode", "Data model (0: legacy, 1: section)",cxxopts::value<int>()->default_value("1"));
        ;

    try {
        auto result = options.parse(argc, argv);
        // print help message if configured
        if (result.count("help")) {
            std::cout << options.help() << std::endl;
            exit(1);
        }
        if (result.count("dry_run")) {
            std::cout << "Dry run enabled. No json will be dumped" << std::endl;
            dry_run = true;
        }
        if (result.count("edges_only")) {
            std::cout << "Print edge info only" << std::endl;
            edges_only = true;
        }
        if (result.count("bt_only")) {
            std::cout << "Print bt info only" << std::endl;
            bt_only = true;
        }
        if (result.count("input")>=1) {
            if(result.count("input")>2) {
                std::cout << "Warning: multiple input directory configured. Only use the last one!" << std::endl;
            }
            input_dir = result["input"].as<std::string>();
        } else {
            std::cout << "-i or --input must be specified!" << std::endl;
            exit(1);
        }
	    if (result.count("line_info_dump") >= 1) {
            if (result.count("line_info_dump") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            dump_dir = result["line_info_dump"].as<std::string>();
        } else {
            std::cout << "-d or --line_info_dump must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("filter_bt") >= 1) {
            if (result.count("filter_bt") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            fb_dir = result["filter_bt"].as<std::string>();
        }
     
        if (result.count("duration") >= 1) {
            if (result.count("duration") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            duration = 2500000 * result["duration"].as<uint64_t>();
        } else {
            std::cout << "-dur or --duration must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("interval") >= 1) {
            if (result.count("interval") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            interval = 2500000 * result["interval"].as<uint64_t>();
        } else {
            std::cout << "-inter or --interval must be specified!" << std::endl;
            exit(1);
        }
        output = result["output"].as<std::string>();
        if (result.count("force")) {
            is_force = true;
        }
        if (result.count("mode")) {
            mode = result["mode"].as<int>();
        }
        std::cout << "Configured: " << std::endl;
        std::cout << "\t" << "Input: " << input_dir << std::endl;
        std::cout << "\t" << "Output: " << output << std::endl;
    } catch (cxxopts::exceptions::exception e) {
        std::cout << "Error: " << e.what() << std::endl;
        std::cout << options.help() << std::endl;
        exit(1);
    }
}

int main(int argc, char *argv[]) {
    // arg parse
    parse(argc, argv);
    try {
        if(fs::exists(output)) {
            if(is_force) {
                fs::remove(output);
            } else {
                std::cout << "Error: output file (" << output << ") exists!" << std::endl;
                exit(1);
            }
        }
        RecordReader* _reader = nullptr;
        if (mode == 0)
        {
            _reader = new RecordReader(input_dir.c_str(),DATA_MODEL,dump_dir.empty() ? nullptr : dump_dir.c_str());
        }
        else
        {
            _reader = new RecordReader(input_dir.c_str(),SECTION_MODEL,dump_dir.empty() ? nullptr : dump_dir.c_str());
        }
        RecordReader reader(input_dir.c_str(),DATA_MODEL,dump_dir.c_str());
        RecordTraceCollection& traces = reader.get_all_traces();
        RankMetaCollection& metas = reader.get_all_meta_maps();
        RecordTraceExtCollection& rte_collection = reader.get_all_ext_traces();
        // Align traces for each host nodes first
        TimelineAlignment ta;
        ta.align(traces, metas);

        DependancyGraph* graph = CreateDependancyGraphSliceAll(traces, rte_collection, metas, false, interval, duration);

        BacktraceCollection* backtraces = reader.has_backtrace() ? &reader.get_all_backtraces() : nullptr;
        // Here we assume all ranks collect identical pmu events
        const auto &pmu_event_list = traces[0]->pmu_event_list();

        if (!dry_run) {
            if (edges_only) {
                graph->dump_edges(output.c_str());
            } else if (bt_only) {
                graph->dump_backtrace(output.c_str(), backtraces, fb_dir.c_str());
            } else {
                graph->dump_nodes(output.c_str(),  pmu_event_list, rte_collection);
            }
        }

        delete graph;
    } catch (fs::filesystem_error const& e) {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    return 0;
}
