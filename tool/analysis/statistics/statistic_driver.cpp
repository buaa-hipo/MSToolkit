#include "statistic.h"
#include <iostream>
#include "utils/cxxopts.hpp"
#include <filesystem>
#include <stdio.h>
#include <fstream>

namespace fs = std::filesystem;

std::string input_dir;
std::string mode;
std::string output_dir;
std::ofstream trace_file;
std::ofstream pmu_file;
std::string dump_dir;
bool ENABLE_PMU_METRICS = false;

void parse(int argc, char *argv[]) {
    // TODO: use cxxopts (similiar with timeline alignment tests) to parse the arguments.
   cxxopts::Options options("jsiread", "Read the measurement directory generated by jsirun.");
    options.add_options()
        ("h,help", "Print help")
        ("i,input", "Input measurement directory generated by jsirun", cxxopts::value<std::string>())
        ("m,mode", "Derive mode of statistic(flat, bottom_up, top_down). Default: flat", cxxopts::value<std::string>()->default_value("flat"))
        ("o,output", "Output file to store readable outputs.", cxxopts::value<std::string>())
        ("p,pmu", "Derive PMU metrics.")
        ("l,line_info_dump", "Input line info directory dumped by dwarf_line_info_dump",
                         cxxopts::value<std::string>())
        ;

    try {
        auto result = options.parse(argc, argv);
        // print help message if configured
        if (result.count("help")) {
            std::cout << options.help() << std::endl;
            exit(1);
        }
        if (result.count("input")>=1) {
            if(result.count("input")>2) {
                std::cout << "Warning: multiple input directory configured. Only use the last one!" << std::endl;
            }
            input_dir = result["input"].as<std::string>();
        } else {
            std::cout << "-i or --input must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("mode")==0) {
            mode = "flat";
        }
        else if (result.count("mode")==1) {
            mode = result["mode"].as<std::string>();
        }
        else {
            std::cout << "-m or --mode must have only one argument." << std::endl;
            exit(1);
        }
        if (result.count("output")) {
            output_dir = result["output"].as<std::string>();
        }
        else {
            std::cout << "-o or --output must be specified!" << std::endl;
            exit(1);
        }
        if (result.count("line_info_dump") >= 1) {
            if (result.count("line_info_dump") > 2) {
                std::cout << "Warning: multiple input line info directory configured. Only use the last one!"
                          << std::endl;
            }
            dump_dir = result["line_info_dump"].as<std::string>();
        } 
        else {
            std::cout << "-l or --line_info_dump not specified! Runtime dwarf addr2line will be used, which will cause a great slowdown!" << std::endl;
        }
        if (result.count("pmu")) {
            ENABLE_PMU_METRICS = true;
        }
        std::cout << "Configured: " << std::endl;
        std::cout << "\t" << "Input: " << input_dir << std::endl;
        std::cout << "\t" <<  "Mode: " << mode << std::endl;
    } catch (cxxopts::exceptions::exception e) {
        std::cout << "Error: " << e.what() << std::endl;
        std::cout << options.help() << std::endl;
        exit(1);
    }
}

void generate_total_time(Statistics::time_t total_time) {
    // Print total execution time
    trace_file << "Total Execution time: " << std::endl;
    trace_file << "\t" << total_time.cycle << " (cycles)" << std::endl;
    trace_file << "\t" << total_time.msec() << " (ms)" << std::endl;
    trace_file << "\t" << total_time.nsec() << " (ns)" << std::endl;
}

void generate_func_stat(Statistics::FuncStatMap* funcStatMap) {
    Statistics::FuncStatMap* all_stat_map = funcStatMap;

    trace_file << "**********************************" << std::endl;
    trace_file << "**        Function State        **" << std::endl;
    trace_file << "**********************************" << std::endl;

    //Sort
    std::vector<std::pair<std::string, Statistics::func_stat_t> > tmp;
    for (auto& i : (*all_stat_map)) {
        tmp.push_back(i);
    }
    std::sort (tmp.begin(), tmp.end(),[=](std::pair<std::string, Statistics::func_stat_t>& a, std::pair<std::string, Statistics::func_stat_t>& b) {
        return a.second.tot_time.cycle > b.second.tot_time.cycle;
    });
    
    //Print all function state
    for (int i = 0; i < tmp.size(); i++) {
        std::string name = tmp.at(i).first;
        Statistics::func_stat_t stat = tmp.at(i).second;
        trace_file << "======" << name << "======" << std::endl;
        trace_file << "Total time: " << stat.tot_time.cycle <<  "(cycles)" << stat.tot_time.sec() << "(s)" << std::endl;
        trace_file << "Average time: " << stat.avg_time.cycle <<  "(cycles)" << stat.avg_time.sec() << "(s)" << std::endl;
        trace_file << "Standard deviation: " << stat.std_time.sec() << "(s)" << std::endl;
        trace_file << "Call times: " << stat.n_call << std::endl;
        trace_file << std::endl;
    }
}

void generate_comm_ratio_dist(Statistics& sta, std::vector<double> comm_ratio_dist) {
    double* avg = (double*)malloc(sizeof(double));
    double* std = (double*)malloc(sizeof(double));

    trace_file << "**********************************" << std::endl;
    trace_file << "**        Comm Ratio Dist       **" << std::endl;
    trace_file << "**********************************" << std::endl;

    sta.get_Comm_Ratio_dist(comm_ratio_dist, avg, std);
    //Print communication ratio distribution
    for (int rank = 0; rank < comm_ratio_dist.size(); rank++) {
        trace_file << ">>>>>>" << "RANK " << rank << ": " << comm_ratio_dist[rank] << std::endl;
    }
    trace_file << "Average: " << *(avg) << std::endl;
    trace_file << "Stand Deviation: " << *(std) << std::endl;

    free(avg);
    free(std);
}

void generate_top_down(Statistics& sta) {
    sta.dump_top_down_trees(output_dir);
}

void generate_bottom_up(Statistics& sta) {
    sta.dump_bottom_up_trees(output_dir);
}

void generate_via_mode(Statistics& sta, Statistics::DeriveMode m) {
    Statistics::time_t totalTime;
    Statistics::FuncStatMap funcStatMap;
    std::vector<double> comm_ratio_dist;
    sta.iter_record(totalTime, funcStatMap, comm_ratio_dist, m);
    if (m == Statistics::FLAT) {
        generate_total_time(totalTime);
        generate_func_stat(&funcStatMap);
        generate_comm_ratio_dist(sta, comm_ratio_dist);
    }
    else if (m == Statistics::TOP_DOWN) {
        generate_top_down(sta);
    }
    else if (m == Statistics::BOTTOM_UP) {
        generate_bottom_up(sta);
    }
    
}

void derive_pmu_metrics(Statistics& sta) {
    std::vector<Statistics::PMUStatMap> pmuStatMapDist;
    sta.RegisterMetricFunc("CPI", builtin_metrics::deriveCPI);
    sta.get_metrics_dist(pmuStatMapDist);
    for (int rank = 0; rank < pmuStatMapDist.size(); rank++) {
        Statistics::PMUStatMap pmuStatMap = pmuStatMapDist.at(rank);
        std::string pmu_dir = output_dir + "/pmu." + std::to_string(rank);
        pmu_file.open(pmu_dir);
        
        for (auto it = pmuStatMap.begin(); it != pmuStatMap.end(); it++) {
            std::string func_name = it->first;
            std::unordered_map<std::string, Statistics::pmu_stat_t> pmuMap = it->second;

            pmu_file << "======" << func_name << "======" << std::endl;
            for (auto pmui = pmuMap.begin(); pmui != pmuMap.end(); pmui++) {
                std::string pmu_event_name = pmui->first;
                Statistics::pmu_stat_t stat = pmui->second;
                pmu_file << "-----------" << pmu_event_name << "-----------" << std::endl;
                if (pmu_event_name != "CPI") {
                    pmu_file << "Total: " << stat.tot << std::endl;
                }
                else {
                    pmu_file << "Total: " << "---" << std::endl;
                }
                pmu_file << "Average: " << stat.avg << std::endl;
                pmu_file << "Standard deviation: " << stat.std << std::endl;
                pmu_file << "Call times: " << stat.n_call << std::endl;
                pmu_file << std::endl;
            }
            pmu_file << std::endl;
            pmu_file << std::endl;
        }
        pmu_file.close();
    }
}

// TODO: implement a driver to derive statistics from the given measurement directory.
int main(int argc, char* argv[]) {
    // 1. parse parameters
    parse(argc, argv);
    // 2. load measurement directory using record reader
    try {
        RecordReader reader(input_dir.c_str(),DATA_MODEL,dump_dir.empty() ? nullptr : dump_dir.c_str());
        RecordTraceCollection& traces = reader.get_all_traces();
        RankMetaCollection& meta_maps = reader.get_all_meta_maps();
        BacktraceCollection& backtraces= reader.get_all_backtraces();
        // 3. derive the requested statistics from the record
        Statistics sta(traces, meta_maps, backtraces);
        // 4. generate summary/detailed reports
        if (std::filesystem::exists(output_dir)) {
            std::filesystem::remove_all(output_dir);
        }
        if (!std::filesystem::create_directories(output_dir)) {
                std::cout << "Error: failed to create output directory (" << output_dir << ")!" << std::endl;
                exit(1);
        }
        std::string trace_dir = output_dir + "/trace";
        trace_file.open(trace_dir);
        if (mode == "flat") {
            generate_via_mode(sta, Statistics::FLAT);
        }
        else if (mode == "bottom_up") {
            generate_via_mode(sta, Statistics::BOTTOM_UP);
        }
        else {
            generate_via_mode(sta, Statistics::TOP_DOWN);
        }
        if (ENABLE_PMU_METRICS) {
            RecordTrace& rt = *(traces[0]);
            auto& event_list = rt.pmu_event_list();
            if (std::find(event_list.begin(), event_list.end(), "PAPI_TOT_CYC") == event_list.end()) {
                JSI_WARN("CPI may not be derived accurately, as PAPI_TOT_CYC not found, using cycle instead.\n");
            }

	        derive_pmu_metrics(sta);
        }
        
    } catch (fs::filesystem_error const& e) {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    return 0;
}
