import numpy as np
from scipy.interpolate import griddata
import matplotlib.pyplot as plt
import argparse
import sys
import shutil
import os

NSEC = 1
USEC = 1000
MSEC = 1000*USEC
SEC  = 1000*MSEC 

TIME_UNIT = MSEC
TIME_UNIT_STR = "ms"

def read_host_csv(host_csv):
    hosts = {}
    host_list = {} 
    with open(host_csv) as f:
        for line in f:
            items = line.split(',')
            rank = int(items[0])
            host = items[1][:-1]
            hosts[rank] = host
            host_list[host] = 0
    hlist = list(host_list.keys())
    hlist.sort()
    return hosts, hlist

def read_csv(csv_file):
    max_size = 0
    data = {}
    resolution = 0
    with open(csv_file) as f:
        resolution = 0
        for line in f:
            if resolution==0:
                resolution=int(line)
                continue
            items = line[:-1].split(',')
            rank = int(items[0])
            data[rank] = [ float(i) for i in items[1:] ]
            if max_size < len(data[rank]):
                max_size = len(data[rank])
    for r in data.keys():
        data[r] = data[r] + [ 1 for i in range(len(data[r]),max_size) ]
    return resolution, data, max_size

def draw_heatmap(csv_file, fig_file, time_threshold, node_level, host_csv, en_start):
    if not os.path.exists(csv_file):
        print("Heatmap data %s not exist. Ignore drawing heatmap for it." % csv_file)
        return 
    read_host_csv(host_csv)
    print("Loading csv file... %s" % csv_file)
    resolution, data_map, max_size = read_csv(csv_file)
    data = []
    for i in range(0, max(data_map.keys())):
        if i in data_map.keys():
            data.append(data_map[i])
        else:
            data.append([1 for i in range(0,max_size)])
    print("Draw heatmap...")
    f, ax = plt.subplots(1, 1, figsize=(12, 6))
    im = ax.imshow(data, aspect='auto', interpolation ='nearest', cmap='Blues', vmin=0, vmax=1)
    ax.set_xlabel("Time (%s)" % TIME_UNIT_STR)
    ax.set_ylabel("MPI Process")
    ax.set_yticklabels([])
    xticks = ax.get_xticks()
    xticklabels = []
    for i in range(len(xticks)):
        xticklabels.append(xticks[i]*resolution)
    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels)
    ax.set_xlim(0, max_size)

    # Create colorbar
    cbar = ax.figure.colorbar(im, ax=ax)

    f.savefig(fig_file, bbox_inches = 'tight')
    print("Figure saved to %s" % fig_file)
    
def main():
    parser = argparse.ArgumentParser(description='Draw heatmap from csv generated by variance_anaylsis.')
    parser.add_argument('--input', help='the variance directory containing csv generated by variance_analysis', default='variance')
    parser.add_argument('--output', help='output directory', default='heatmaps/')
    parser.add_argument('--time', help='time threshold (%s) to cutoff the variance heatmap. 0 for full trace.' % TIME_UNIT_STR, default=0)
    parser.add_argument('--node_level', help='Merge by node level.', action="store_true", default=False)
    parser.add_argument('--format', help='png,pdf,jpg, default is png.', default="png")
    parser.add_argument('--start', help='start time', default=0)
    args = parser.parse_args()
    
    if not os.path.exists(args.output):
        os.mkdir(args.output, 0o777)
        print("Directory %s created" % args.output)
    
    time = int(args.time)
    
    draw_heatmap(args.input+"/comm_heat.csv", args.output+"/comm."+args.format, time, args.node_level, args.input+"/host.csv", int(args.start))
    draw_heatmap(args.input+"/calc_heat.csv", args.output+"/calc."+args.format, time, args.node_level, args.input+"/host.csv", int(args.start))
    draw_heatmap(args.input+"/accl_calc_heat.csv", args.output+"/accl_calc."+args.format, time, args.node_level, args.input+"/host.csv", int(args.start))
    draw_heatmap(args.input+"/accl_memcpy_heat.csv", args.output+"/accl_memcpy."+args.format, time, args.node_level, args.input+"/host.csv", int(args.start))
    
main()